// License: Apache 2.0. See LICENSE file in root directory.
// Realsense Module
// Subscribes to Realsense Messages and Saves to Disk

#include <chrono>
#include <thread>
#include <set>
#include <map>
#include <math.h>
#include <string>
#include <sstream>
#include <iostream>
#include <algorithm>
#include <iomanip>
#include <vector>
#include <atomic>

#include <librealsense2/rs.hpp>
#include <gflags/gflags.h>
#include <glog/logging.h>
#include <ecal/ecal.h>
#include <ecal/msg/protobuf/publisher.h>
#include <ecal/msg/protobuf/subscriber.h>
#include <ecal/msg/protobuf/server.h>
#include <opencv2/opencv.hpp>
#include <opencv2/core/utils/filesystem.hpp>
#include <Open3D/Visualization/Visualizer/Visualizer.h>
#include <Open3D/Integration/ScalableTSDFVolume.h>

#include "rspub/utility.hpp"
#include "Integrate.pb.h" // the google compiler autogenerated service class

#define degreesToRadians(angleDegrees) (angleDegrees * M_PI / 180.0)
#define radiansToDegrees(angleRadians) (angleRadians * 180.0 / M_PI)

using namespace std::chrono_literals;
using namespace std::string_literals;

// Command line flags
DEFINE_string(config, "./config/rsintegrate_default.toml", "Path to config file");

// START Global Variables
/////////////////////////

// Keep track of previous pose changes.
double min_translate_change = 0.0;
double min_rotation_change = 0.0;
rspub_pb::Vec3 previous_pose_translation;
rspub_pb::Vec4 previous_pose_rotation;
///////////////////////
// END GLOBAL Variables

const google::protobuf::EnumDescriptor *descriptor_scene = rspub_pb::SceneRequestType_descriptor();
const google::protobuf::EnumDescriptor *descriptor_data = rspub_pb::DataRequestType_descriptor();

using TSDFVolumeColorType =  open3d::integration::TSDFVolumeColorType;
using STSDFVolume = open3d::integration::ScalableTSDFVolume;
namespace rspub
{

enum State {STOP, START};
struct Scene
{
	std::string scene_name;
	std::shared_ptr<STSDFVolume> volume;
	State state;
};
// PingService implementation
class IntegrateServiceImpl : public rspub_pb::IntegrateService
{
public:
	IntegrateServiceImpl(toml::value tcf):tcf(tcf)
	{

		// create subscriber
		sub_rgbd = rspub::SubImage("RGBDMessage");
		// auto rgbd_rec_callback = std::bind(this->OnRGBDMessage, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, std::placeholders::_4);
		// sub_rgbd.AddReceiveCallback(rgbd_rec_callback);
		sub_rgbd.AddReceiveCallback([this](const char *topic_name_, const rspub_pb::ImageMessage &im_msg, const long long time_, const long long clock_, const long long stuff_){ 
			OnRGBDMessage(topic_name_, im_msg, time_, clock_); 
			});
	}

	/**
	 * @brief Creates a TSDFVolume to be intergrated
	 * 
	 * @param scene_name 
	 */
	bool add_scene(std::string scene_name)
	{
		auto tsdf = toml::find(tcf, "scalable_tsdf");
		double voxel_length = toml::find_or<double>(tsdf, "voxel_length", 0.03125);
		double sdf_trunc = toml::find_or<double>(tsdf, "sdf_trunc", 0.08);
        TSDFVolumeColorType color_type = TSDFVolumeColorType(toml::find_or<int>(tsdf, "color_type", 1));
    	int depth_sampling_stride = toml::find_or<int>(tsdf, "depth_sampling_stride", 4);
        int volume_unit_resolution = 16;

		scene_names.insert(scene_name);
		auto ptr = std::make_shared<STSDFVolume>(voxel_length, sdf_trunc, color_type, volume_unit_resolution, depth_sampling_stride);
		
		Scene scene_;
		scene_.scene_name = scene_name;
		scene_.volume = ptr;
		scene_.state = State::STOP;

		scene_map[scene_name] = scene_;

		return true;

	}
	bool remove_scene(std::string scene_name)
	{
		auto it = scene_map.find (scene_name);
		if (it == scene_map.end()){
			return false;
		}
  		scene_map.erase( it, scene_map.end());
		return true;
	}
	bool start_scene(std::string scene_name)
	{
		auto it = scene_map.find (scene_name);
		if (it == scene_map.end()){
			add_scene(scene_name);
		}
		auto scene = scene_map[scene_name];
		scene.state = State::START;
		return true;

	}
	bool stop_scene(std::string scene_name)
	{
		auto it = scene_map.find (scene_name);
		if (it == scene_map.end()){
			return false;
		}
		auto scene = scene_map[scene_name];
		scene.state = State::STOP;
		return true;

	}
	void IntegrateScene(::google::protobuf::RpcController* /* controller_ */, const rspub_pb::IntegrateRequest* request_, rspub_pb::IntegrateResponse* response_, ::google::protobuf::Closure* /* done_ */)
	{
		// print request
		LOG(INFO) << "Received Intregate Scene Request " << descriptor_scene->FindValueByNumber(request_->type())->name() 
					<< ": " << request_->scene();

		switch (request_->type())
		{
			case rspub_pb::SceneRequestType::ADD:
			{
				LOG(INFO) << "Got Add";
				auto success = add_scene(request_->scene());
				response_->set_success(success);
				break;
			}
			case rspub_pb::SceneRequestType::REMOVE:
			{
				LOG(INFO) << "Got Remove";
				auto success = remove_scene(request_->scene());
				if (!success)
				{
					response_->set_message("DOES NOT EXIST");
				}
				response_->set_success(success);
				break;
			}
			case rspub_pb::SceneRequestType::START:
			{
				LOG(INFO) << "Got Start";
				auto success = start_scene(request_->scene());
				response_->set_success(success);
				break;
			}
			case rspub_pb::SceneRequestType::STOP:
			{
				LOG(INFO) << "Got Stop";
				auto success = stop_scene(request_->scene());
				response_->set_success(success);
				break;
			}

			default:
				break;
		}
	}

	void OnRGBDMessage(const char *topic_name_, const rspub_pb::ImageMessage &im_msg, const long long time_, const long long clock_)
	{
		double now = std::chrono::duration<double, std::milli>(std::chrono::system_clock::now().time_since_epoch()).count();
		VLOG(1) << std::setprecision(0) << std::fixed << "Received RGBDMessage; now: " << now << "; send_ts: " << time_ / 1000 << "; hardware_ts: " << im_msg.hardware_ts() << std::endl;


		auto w = im_msg.width();
		auto h = im_msg.height();
		auto image_data_str = im_msg.image_data();
		const char *image_data_ptr = image_data_str.c_str();

		auto image_data_second_str = im_msg.image_data_second();
		const char *image_data_second_ptr = image_data_second_str.c_str();

	}
	void ExtractScene(::google::protobuf::RpcController* /* controller_ */, const rspub_pb::ExtractRequest* request_, rspub_pb::IntegrateResponse* response_, ::google::protobuf::Closure* /* done_ */)
	{
		// print request
		std::cout << "Received Extract Request" << std::endl;
		// and send response
		response_->set_message("PONG");
	}

protected:
	std::shared_ptr<open3d::visualization::Visualizer> vis;
	std::map<std::string, Scene> scene_map;
	std::set<std::string> scene_names;
	rspub::SubImage sub_rgbd;
	toml::value tcf;
	int value = 1;

};




} // namespace rspub


int main(int argc, char *argv[]) try
{
	google::InitGoogleLogging(argv[0]);
	LOG(INFO) << "Starting rs-integrate-server";
	// Parse command line flags
	gflags::ParseCommandLineFlags(&argc, &argv, true);
	const auto tcf = toml::parse(FLAGS_config);

	min_translate_change = toml::find_or<double>(tcf, "min_translate_change", min_translate_change); // meters
	min_rotation_change = toml::find_or<double>(tcf, "min_rotation_change", min_rotation_change); // degrees
	min_rotation_change = (1.0 - cos(degreesToRadians(min_rotation_change))) / 2.0; // number between 0-1
	
	// initialize eCAL API
	eCAL::Initialize(0, nullptr, "RSIntegrate");


	  // create IntegrationServer server
	std::shared_ptr<rspub::IntegrateServiceImpl> integrate_service_impl = std::make_shared<rspub::IntegrateServiceImpl>(tcf);
	eCAL::protobuf::CServiceServer<rspub_pb::IntegrateService> integrate_service(integrate_service_impl);


	// enable to receive process internal publications

	// Have to set the global variable here this way
	previous_pose_translation.set_x(0);
	previous_pose_translation.set_y(0);
	previous_pose_translation.set_z(0);

	previous_pose_rotation.set_x(0);
	previous_pose_rotation.set_y(0);
	previous_pose_rotation.set_z(0);
	previous_pose_rotation.set_w(0);




	eCAL::Process::SleepMS(1000);
	while (eCAL::Ok())
	{
		eCAL::Process::SleepMS(10);
	}
	eCAL::Finalize();
}
catch (const std::exception &e)
{

	std::cerr << e.what() << std::endl;

	return EXIT_FAILURE;
}
